# -*- coding: UTF-8 -*-

"""
HTML annotation rendering. Heavily based on Cython/Compiler/Annotate.py
"""

from __future__ import print_function, division, absolute_import

import sys
import cgi
import os
from numba.lexing import lex_source
from .annotate import format_annotations, groupdict, A_c_api
from .step import Template

css = u"""
<style type="text/css">

body { font-family: courier; font-size: 12; }

.code  { font-size: 9; color: #444444; display: none; margin-left: 20px; }
.py_c_api  { color: red; }
.py_macro_api  { color: #FF7000; }
.pyx_c_api  { color: #FF3000; }

.error_goto  { color: #FFA000; }

.tag  {  }

.coerce  { color: #008000; border: 1px dotted #008000 }

.py_attr { color: #FF0000; font-weight: bold; }
.c_attr  { color: #0000FF; }

.py_call { color: #FF0000; font-weight: bold; }
.c_call  { color: #0000FF; }

.line { margin: 0em }

</style>
"""

script = u"""
<script>
function toggleDiv(id) {
    theDiv = document.getElementById(id);
    if (theDiv.style.display == 'none') theDiv.style.display = 'block';
    else theDiv.style.display = 'none';
}
</script>
"""

head = u"""
<!-- Generated by Numba %s -->\

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

{css}
{script}

</head>
"""

def get_linecolor(annotations):
    adict = groupdict(annotations, "type")
    (_, count), = adict.get(A_c_api, [(A_c_api, 0)])
    score = 5 * count
    return u"FFFF%02x" % int(255/(1+score/10.0))

def render_lines(py_source, llvm_intermediate, emit):
    for lineno, line in sorted(py_source.linemap.iteritems()):
        color = get_linecolor(py_source.annotations.get(lineno, []))
        emit(u"<pre class='line' style='background-color: #%s' "
             u"onclick='toggleDiv(\"line%s\")'>\n" % (color, lineno))

        emit(u" %d: " % lineno)
        # emit(lex_source(line, "python", "html") + u"\n")
        emit(cgi.escape(line) + u"\n")
        emit(u'</pre>\n')

        llvm_lines = [llvm_intermediate.source.linemap[llineno]
                          for llineno in llvm_intermediate.linenomap[lineno]]
        emit(u"<pre id='line%s' class='code' "
             u"style='background-color: #%s'>\n%s</pre>\n" %
                (lineno, color, lex_source(u"\n".join(llvm_lines), "llvm", "html")))

def render(program, emit=sys.stdout.write,
           intermediate_names=(), inline=True):
    """
    Render a Program as html.
    """
    #emit(head.format(css=css, script=script))
    #emit(u"<body>")
    #irs = groupdict(program.intermediates, "name")
    #llvm_intermediate, = irs["llvm"]
    #render_lines(program.python_source, llvm_intermediate, emit)
    #emit(u"</body></html>")

    root = os.path.join(os.path.dirname(__file__))
    if inline:
        templatefile = os.path.join(root, 'annotate_inline_template.html')
    else:
        templatefile = os.path.join(root, 'annotate_template.html')

    with open(templatefile, 'r') as f:
        template = f.read()

    html_codes = [('&', '&amp;'), ('<', '&lt;'), ('>', '&gt;'),
                  ('"', '&quot;'), ("'", '&#39;'), (' ', '&nbsp;')]

    data = {'lines': []}

    for num, python_source in sorted(program.python_source.linemap.items()):
        for code in html_codes:
            python_source = python_source.replace(code[0], code[1])

        llvm_nums = program.intermediates[0].linenomap[num]
        llvm_source = ''
        for llvm_num in llvm_nums:
            source = program.intermediates[0].source.linemap[llvm_num]
            for code in html_codes:
                source = source.replace(code[0], code[1])
            llvm_source += source + '<br/>'
        data['lines'].append({'num':num,
                              'python_source':python_source,
                              'llvm_source':llvm_source})

    html = Template(template).expand(data)

    emit(html)
